<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

<title>Port Map</title>
<style>
  html,body{margin:0;height:100%}
  #stage{position:relative;width:100vw;height:100svh;overflow:hidden;background:#49aeb6}
  svg{width:100%;height:100%;display:block;touch-action:none;user-select:none}

  .hud{position:absolute;z-index:30;left:12px;top:12px;display:flex;gap:8px;flex-wrap:wrap}
  .btn{padding:8px 12px;border-radius:10px;background:#ffffffcc;border:1px solid #d0d0d0;font:600 13px/1 system-ui}
  .btn:active{transform:translateY(1px)}
  .warn{position:absolute;z-index:40;right:12px;top:12px;background:#fff3cd;border:1px solid #ffe69c;color:#7f5f00;padding:8px 10px;border-radius:10px;font:600 13px/1.2 system-ui}

@supports (-webkit-touch-callout: none){
  #stage{ height:-webkit-fill-available; }
}
  .jobs{position:absolute;z-index:35;left:50%;top:14px;transform:translateX(-50%);
        background:#ffffff;border:1px solid #e4e7eb;box-shadow:0 10px 30px #0003;
        border-radius:14px;width:min(1100px,94vw);overflow:hidden}
  .jobs-header{display:flex;align-items:center;gap:10px;padding:10px 12px;background:#f8fafc;border-bottom:1px solid #eef1f4}
  .jobs-title{font:700 15px/1.2 system-ui;color:#1b2734}
  .jobs-toggle{margin-left:auto;border:0;background:#edf2f7;border-radius:10px;padding:6px 10px;font:700 13px;cursor:pointer}
  .jobs-body{max-height:40vh;overflow:auto}
  table{width:100%;border-collapse:collapse;font:500 13px/1.45 system-ui}
  th,td{padding:8px 10px;border-bottom:1px solid #eef2f6;white-space:nowrap}
  th{position:sticky;top:0;background:#f8fafc;font-weight:700;color:#44566c;z-index:1}
  td.ship{font-weight:700;color:#163a6b}
  .bar{height:18px;background:#e9ecef;border-radius:5px;overflow:hidden;text-align: center;  }
  .bar>i{display:block;height:100%;background:#34c759}
  tr:hover{background:#f6fbff;cursor:pointer}

 
  .cards{display:none;padding:10px;gap:10px}
  .card{border:1px solid #eef1f4;border-radius:12px;padding:10px 12px;background:#fff}
  .card .hdr{font:700 14px/1.2 system-ui;color:#163a6b;margin-bottom:6px}
  .card .cols{display:grid;grid-template-columns:1fr 1fr;gap:6px 12px;font:500 13px/1.45 system-ui}
  .card .cols div:nth-child(odd){color:#607085}
  .card .cols div:nth-child(even){color:#1b2734}
 
  .chev{
    position:absolute;z-index:50;right:10px;top:10px;
    width:36px;height:36px;border-radius:10px;border:1px solid #e3e6ea;
    background:#fff;display:none;align-items:center;justify-content:center;
    font:900 16px/1 system-ui;box-shadow:0 6px 16px #0003;cursor:pointer
  }
  .chev.rotate{transform:rotate(180deg)}
  @media (max-width: 960px){
    .jobs{
      top:0; left:auto; right:0; transform:none;
      height:100%; width:min(96vw, 420px); max-width:96vw;
      border-radius:0; box-shadow:-10px 0 30px #0004;
      translate:100% 0; transition:translate .25s ease;
    }
    .jobs.open{ translate:0 0 }
    .jobs-body{max-height:calc(100% - 46px)}
    .chev{display:flex}
    #jobsTable{display:none}
    #jobsCards{display:grid}
  
    .jobs-toggle{display:none}
  }
  @media (max-width:640px){ .hide-sm{display:none} }

 
  .panel{position:absolute;z-index:40;left:50%;top:18px;transform:translateX(-50%);
         background:#fff;border:1px solid #e3e6ea;box-shadow:0 10px 30px #0002;border-radius:12px;
         min-width:320px;max-width:92vw;padding:14px 16px;display:none}
  .panel h3{margin:0 0 8px;font:700 18px/1.2 system-ui}
  .rows{display:grid;grid-template-columns:120px 1fr;gap:6px 12px;font:500 13px/1.5 system-ui}
  .rows div:nth-child(odd){color:#607085}
  .rows div:nth-child(even){color:#1b2734}
  .close{position:absolute;right:10px;top:10px;border:0;background:#f3f4f6;border-radius:8px;padding:6px 10px;cursor:pointer}

  #layer-ships{pointer-events:visiblePainted}
  .ship{pointer-events:visiblePainted}
  .ship image,.ship text{pointer-events:none}
  .ship .hit{pointer-events:all;cursor:pointer}

  /* Berth label colors (hover + active) */
  .berth-tab{fill:#163a6b;transition:fill .15s ease}
  .berth:hover .berth-tab{fill:#ff8a00}
  .berth.active .berth-tab{fill:#ff8a00}

 .clouds{
  position:absolute;
  top:0; left:0; 
  width:100%; height:100%;
  pointer-events:none;    
  overflow:hidden;
}

.cloud{
  position:absolute;
  top:-20px;           
  width:120px;
  opacity:0.8;
}

.cloud1{
  animation:cloudX 60s linear infinite;
}
.cloud2{
  animation:cloudX 90s linear infinite reverse;
  width:150px;
  top:-30px;            
}
.cloud3{
  animation:cloudX 75s linear infinite;
  width:100px;
  top:-15px;
}

 
@keyframes cloudX {
  0%   { left:-200px; }
  100% { left:100vw; }
}
.pop{
  position:absolute; z-index:60;
  min-width:300px; max-width:min(92vw,460px);
  border-top: none;
  background:#fff;   border-radius:12px;
  box-shadow:0 12px 36px #0003;
  overflow:visible;                  
  display:none;
}
 
.pop.show{display:block}
.pop .hd{
  background:#0b66c3;
  color:#fff;
  font:800 15px/1.4 system-ui;
  padding:10px 12px;
  text-align:center;                  
  display:flex;
  align-items:center;                 
  justify-content:center;              
  border-top-left-radius:12px;        
  border-top-right-radius:12px;
}

.pop .bd{
  padding:12px;
  max-height:60vh;       
  overflow-y:auto;        
}
.pop table{width:100%;border-collapse:collapse;table-layout:auto}
.pop td{padding:8px 10px;border-bottom:1px solid #eef2f6;vertical-align:top}
.pop td:first-child{color:#607085;font-weight:600;white-space:nowrap}
.pop td:last-child{color:#0f263d;text-align:right;word-break:break-word}

.pop::before,
.pop::after{
  content:""; position:absolute; width:0; height:0; pointer-events:none;
  left:var(--ax,50%); transform:translateX(-50%);
  border:12px solid transparent;
  display:none;    
}

 
.pop.above::before{ 
  display:block;
  bottom:-22px;
  border-top-color:#dfe5ec;   
  z-index:59;
}
.pop.above::after{ 
  display:block;
  bottom:-21px;
  border-top-color:#fff;      
  z-index:60;
}

 
.pop.below::before,
.pop.below::after{
  display:none !important;
}

.pop{ overflow:visible; }
.pop .bd{ padding:0 }                             
.pop .sec{ border-top:1px solid #e6edf4 }
.pop .sec:first-child{ border-top:0 }

.pop .sec-hd{
  font:800 12px/1.2 system-ui;
  letter-spacing:.2px;
  padding:8px 12px;
  border-bottom:1px solid #e6edf4;
  text-transform:uppercase;
}
.pop .sec-body{ padding:4px 0 }

.pop .sec.table table{ width:100%; border-collapse:collapse; table-layout:fixed; }
.pop .sec.table td{
  padding:8px 12px; border-bottom:1px solid #eef2f6; vertical-align:top;
  font:600 13px/1.45 system-ui;
}
.pop .sec.table td:first-child{ color:#5f7086; width:55% }
.pop .sec.table td:last-child{ color:#0e2438; text-align:right; word-break:break-word }

 
.pop .sec.blue  .sec-hd{ background:#eaf4ff; color:#0c4ea3 }
.pop .sec.amber .sec-hd{ background:#fff6df; color:#7a5200 }
.pop .sec.gray  .sec-hd{ background:#f4f6f8; color:#394a5b }

 
.pop .pill{ display:inline-block; padding:2px 6px; border-radius:6px; font-weight:800; font-size:12px }
.pop .pill.blue{ background:#eaf4ff; color:#0c4ea3 }
.pop .pill.green{ background:#eafaf4; color:#116a52 }
.pop .pill.orange{ background:#fff2e2; color:#a14c00 }

 
.pop .sum-row td{ font-weight:800 }
</style>
</head>
<body>
<div id="stage">
  <div id="pop" class="pop" role="dialog" aria-modal="false">
  <div class="hd" id="popTitle">Tiêu đề</div>
  <div class="bd" id="popBody"></div>
</div>
  <div class="hud">
    <!-- <button class="btn" id="fit">Fit</button>
    <button class="btn" id="cover">Cover</button> -->
    <button class="btn" id="zoomIn">＋</button>
    <button class="btn" id="zoomOut">－</button>
    <!-- <a class="btn" href="data-entry.html">← Data Entry</a> -->
  </div>
  <button class="chev" id="toggleJobs" aria-label="Mở/đóng danh sách">❯</button>
  <div class="warn" id="warn" style="display:none">Chưa có dữ liệu. Hãy nhập ở “Data Entry”.</div>

  <!-- Jobs -->
  <div class="jobs" id="jobsCard">
    <div class="jobs-header">
      <div class="jobs-title">Tiến độ làm hàng (theo tàu)</div>
      <button class="jobs-toggle" id="jobsToggle">Ẩn ▲</button>
    </div>
    <div class="jobs-body" id="jobsBody"  >
      <table id="jobsTable">
        <thead><tr><th>Bến</th><th>Tàu</th><th class="hide-sm">ShipKey</th><th class="hide-sm">ETA → ETD</th><th>%</th></tr></thead>
        <tbody></tbody>
      </table>
      <div id="jobsCards" class="cards"></div>
    </div>
  </div>

  <!-- Panel TÀU -->
  <div class="panel" id="shipPanel">
    <button class="close" id="closePanel">✕</button>
    <h3 id="pName">Tên tàu</h3>
    <div class="rows">
      <div>Tàu:</div><div id="pShipName">—</div>
      <div>Mã chuyến:</div><div id="pShipKey">—</div>
      <div>Bến (theo vị trí):</div><div id="pBerth">—</div>
      <div>Vị trí (u→px):</div><div id="pSpan">—</div>
      <div>Kích thước (ước tính):</div><div id="pSize">—</div>
      <div>Tiến độ:</div><div id="pProg">—</div>
      <div>ETA → ETD:</div><div id="pEtaEtd">—</div>
    </div>
  </div>

  <!-- Panel BẾN -->
  <div class="panel" id="berthPanel">
    <button class="close" id="closeBerth">✕</button>
    <h3 id="bTitle">Tên bến</h3>
    <div class="rows">
      <div>Mã bến:</div><div id="bNo">—</div>
      <div>Chiều dài (m):</div><div id="bLen">—</div>
      <div>Độ sâu TK (hải đồ):</div><div id="bDepth">—</div>
      <div>Tải trọng (tấn):</div><div id="bPayload">—</div>
      <div>Vị trí (u):</div><div id="bSpan">—</div>
    </div>
  </div>

  <!-- World khớp kích thước ảnh map -->
  <svg id="root" viewBox="0 0 3000 2000" preserveAspectRatio="xMidYMid meet">
    <defs>
      <clipPath id="seaClip" clipPathUnits="userSpaceOnUse">
        <rect id="seaClipRect" x="0" y="0" width="0" height="0"/>
      </clipPath>
    </defs>
    <g id="camera">
      <image id="basemap" href="assets/port-map.svg" x="0" y="0" width="3000" height="2000"></image>
      <g id="layer-berths"></g>
      <g id="layer-ships" style="clip-path:url(#seaClip)"></g>
    </g>
  </svg>
  <div class="clouds">
  <img src="assets/cloud.png" class="cloud cloud1">
  <img src="assets/cloud.png" class="cloud cloud2">
  <img src="assets/cloud.png" class="cloud cloud3">
</div>
</div>

<script>
 
const MAP={W:3000,H:2000};
const SEA={x1:80,x2:2920,y:720,height:360};
const SEA_PAD=300,PAD_VIS=6,LANE_GAP_PX=10;
const BEAM_VISUAL_SCALE=1.6,MIN_SHIP_HEIGHT=14;
const SHIP_SPRITES=[{src:'assets/cargo-ship-2.png',w:419,h:94},{src:'assets/tau-tong-hop-1.png',w:419,h:94}];
const CAN_HOVER=matchMedia('(hover:hover)').matches;

/* ===== CAMERA ===== */
const stage=document.getElementById('stage'), svg=document.getElementById('root'), camera=document.getElementById('camera');
let scale=1,tx=0,ty=0; const MIN=0.5,MAX=8;
const apply=()=>camera.setAttribute('transform',`translate(${tx},${ty}) scale(${scale})`);
function fitContain(){const vw=stage.clientWidth,vh=stage.clientHeight;scale=Math.min(vw/MAP.W,vh/MAP.H);tx=(vw-MAP.W*scale)/2;ty=(vh-MAP.H*scale)/2;apply();}
function fitCover(){const vw=stage.clientWidth,vh=stage.clientHeight;scale=Math.max(vw/MAP.W,vh/MAP.H);tx=(vw-MAP.W*scale)/2;ty=(vh-MAP.H*scale)/2;apply();}
function fitHeight(){const vw=stage.clientWidth,vh=stage.clientHeight;scale=vh/MAP.H;tx=(vw-MAP.W*scale)/2;ty=(vh-MAP.H*scale)/2;apply();}
function clientToSvgPoint(x,y){const p=svg.createSVGPoint();p.x=x;p.y=y;return p.matrixTransform(svg.getScreenCTM().inverse());}
function zoomBy(f){const r=svg.getBoundingClientRect(),cx=r.width/2,cy=r.height/2;const p=clientToSvgPoint(cx,cy);const ns=Math.max(MIN,Math.min(MAX,scale*f));tx=p.x-(p.x-tx)*(ns/scale);ty=p.y-(p.y-ty)*(ns/scale);scale=ns;apply();}
// let dragging=false,lx=0,ly=0,lockDrag=false,userInteracted=false;
// svg.addEventListener('pointerdown',e=>{userInteracted=true;lockDrag=!!e.target.closest('.ship, .berth');if(lockDrag)return;dragging=true;lx=e.clientX;ly=e.clientY;svg.setPointerCapture(e.pointerId);});
// svg.addEventListener('pointerup',()=>{dragging=false;lockDrag=false;});
// svg.addEventListener('pointermove',e=>{if(!dragging||lockDrag)return;tx+=e.clientX-lx;ty+=e.clientY-ly;lx=e.clientX;ly=e.clientY;apply();});
// svg.addEventListener('wheel',e=>{e.preven  tDefault();userInteracted=true;zoomBy(e.deltaY>0?0.9:1.1)},{passive:false});
// document.getElementById('fit').onclick=()=>{userInteracted=false;fitContain();};
// document.getElementById('cover').onclick=()=>{userInteracted=false;fitCover();};
document.getElementById('zoomIn').onclick=()=>{userInteracted=true;zoomBy(1.15);};
document.getElementById('zoomOut').onclick=()=>{userInteracted=true;zoomBy(0.87);};
// new ResizeObserver(()=>{if(!userInteracted)fitHeight();}).observe(stage);
// fitHeight();
// ==== Pinch zoom (2 ngón) cho mobile/tablet ====
/* ===== Pan mượt + Quán tính (fling) + Pinch-zoom 2 ngón ===== */
 

/* ===== Pan 1 ngón: giống code cũ, nhưng robust hơn trên mobile ===== */
 const PAN_DAMPING = 0.0012;   // ma sát nhẹ hơn → trôi mượt
const PAN_MIN_SPEED = 0.015;  // tốc độ ngưỡng dừng
const FRAME_MAX = 32;         // clamp dt

/* ===== STATE ===== */
let userInteracted=false;
let dragging=false, lockDrag=false;
let lastX=0, lastY=0;
let vx=0, vy=0;
let flingId=null;

function stopFling(){ if(flingId){ cancelAnimationFrame(flingId); flingId=null; } }
function startFling(){
  stopFling();
  const t0=performance.now();
  function step(t){
    const dt=Math.min(FRAME_MAX, t-(step.last||t0)); step.last=t;
    const k=Math.exp(-PAN_DAMPING*dt);
    vx*=k; vy*=k;
    tx+=vx*dt; ty+=vy*dt;
    apply();
    if(Math.hypot(vx,vy)>PAN_MIN_SPEED) flingId=requestAnimationFrame(step);
    else flingId=null;
  }
  flingId=requestAnimationFrame(step);
}

/* ===== rAF throttle cho pan ===== */
let panQueued=false, panDX=0, panDY=0;
function queuePan(dx,dy){
  panDX+=dx; panDY+=dy;
  if(panQueued) return;
  panQueued=true;
  requestAnimationFrame(()=>{
    tx+=panDX; ty+=panDY;
    apply();
    // velocity EMA để fling
    const dt=16; const wx=panDX/dt, wy=panDY/dt;
    vx=vx*0.8+wx*0.2; vy=vy*0.8+wy*0.2;
    panDX=0; panDY=0; panQueued=false;
  });
}

/* ===== Pinch (incremental) đúng tâm chạm ===== */
const pts=new Map();
let pinching=false;
let pinchPrevDist=0;
let pinchAnchorWorld={x:0,y:0};

function dist(a,b){const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy);}
function mid(a,b){return {x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2};}

/* mỗi frame xử lý pinch một lần để mượt */
let pinchQueued=false;
function processPinch(){
  if(pinchQueued || !pinching || pts.size!==2) return;
  pinchQueued=true;
  requestAnimationFrame(()=>{
    pinchQueued=false;
    const [a,b]=[...pts.values()];
    const d=dist(a,b); if(d<=0) return;

    const r=svg.getBoundingClientRect();
    const m=mid(a,b);
    const mx=m.x - r.left, my=m.y - r.top;

    // scale gia tăng: dùng tỉ lệ với khoảng cách KHÔNG so với start mà so với previous
    const desired = Math.max(MIN, Math.min(MAX, scale*(d/pinchPrevDist)));

    // neo: dùng world point ngay tại midpoint HIỆN TẠI (trước khi đổi scale)
    const world = clientToSvgPoint(m.x, m.y);

    scale = desired;
    tx = mx - world.x*scale;
    ty = my - world.y*scale;
    apply();

    pinchPrevDist = d; // cập nhật mốc đo cho frame tiếp
  });
}

/* ===== HANDLERS ===== */
svg.addEventListener('pointerdown',(e)=>{
  e.preventDefault();
  userInteracted=true;

  // thêm pointer vào set (cho pinch)
  pts.set(e.pointerId, {pointerId:e.pointerId, clientX:e.clientX, clientY:e.clientY});

  // nếu đang có đúng 2 ngón → vào pinch mode (không pan)
  if(pts.size===2){
    const [a,b]=[...pts.values()];
    pinching=true;
    dragging=false;
    pinchPrevDist=dist(a,b);
    const m=mid(a,b);
    pinchAnchorWorld = clientToSvgPoint(m.x, m.y); // dùng khi cần, nhưng ta tính lại mỗi frame bằng world hiện tại
    return;
  }

  // nếu chạm vào đối tượng tương tác thì không pan
  lockDrag = !!e.target.closest('.ship, .berth, .crane, .hit');
  if(lockDrag) return;

  // pan 1 ngón
  stopFling();
  dragging=true;
  lastX=e.clientX; lastY=e.clientY;
},{passive:false});

svg.addEventListener('pointermove',(e)=>{
  // cập nhật vị trí pointer cho pinch
  if(pts.has(e.pointerId)){
    pts.set(e.pointerId, {pointerId:e.pointerId, clientX:e.clientX, clientY:e.clientY});
  }

  if(pinching && pts.size===2){
    processPinch();
    return;
  }

  if(!dragging || lockDrag) return;
  e.preventDefault();
  const dx=e.clientX-lastX, dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;
  queuePan(dx,dy);
},{passive:false});

function endPtr(e){
  pts.delete(e.pointerId);
  if(pinching && pts.size<2){ pinching=false; }
  if(dragging){
    dragging=false;
    if(!lockDrag){
      const boost=(e.pointerType==='touch')?1.25:1.0;
      vx*=boost; vy*=boost;
      if(Math.hypot(vx,vy)>PAN_MIN_SPEED) startFling();
    }
  }
  lockDrag=false;
}
svg.addEventListener('pointerup', endPtr, {passive:true});
svg.addEventListener('pointercancel', endPtr, {passive:true});
svg.addEventListener('pointerleave', endPtr, {passive:true});
svg.addEventListener('pointerout', endPtr, {passive:true});

/* ===== Wheel zoom (desktop) ===== */
svg.addEventListener('wheel',(e)=>{
  e.preventDefault();
  userInteracted=true;
  const r=svg.getBoundingClientRect();
  const cx=r.left+r.width/2, cy=r.top+r.height/2;
  const world=clientToSvgPoint(cx,cy);
  const f = e.deltaY>0?0.9:1.1;
  const ns = Math.max(MIN, Math.min(MAX, scale*f));
  tx = (cx - r.left) - world.x*ns;
  ty = (cy - r.top ) - world.y*ns;
  scale = ns;
  apply();
},{passive:false});

// const activePtrs = new Map();
// let isPinching = false;
// let pinchStartDist = 0;
// let pinchStartScale = 1;
// let pinchAnchorSvg = {x:0, y:0};   // điểm neo trong tọa độ SVG (giữ cố định dưới ngón)
// let pinchStartTx = 0, pinchStartTy = 0;

// function ptrDistance(p1, p2){ const dx=p1.clientX-p2.clientX, dy=p1.clientY-p2.clientY; return Math.hypot(dx,dy); }
// function ptrMidpoint(p1, p2){ return { x:(p1.clientX+p2.clientX)/2, y:(p1.clientY+p2.clientY)/2 }; }

// function startPinch(){
//   if(activePtrs.size !== 2) return;
//   const [a,b] = [...activePtrs.values()];
//   pinchStartDist = ptrDistance(a,b);
//   pinchStartScale = scale;
//   const mid = ptrMidpoint(a,b);
 
//   pinchAnchorSvg = clientToSvgPoint(mid.x, mid.y);
//   pinchStartTx = tx; pinchStartTy = ty;
//   isPinching = true;
//   userInteracted = true;
// }

// function updatePinch(){
//   if(!isPinching || activePtrs.size !== 2) return;
//   const [a,b] = [...activePtrs.values()];
//   const dist = ptrDistance(a,b);
//   if(dist <= 0) return;

//   // scale mới theo tỉ lệ khoảng cách 2 ngón
//   const ns = Math.max(MIN, Math.min(MAX, pinchStartScale * (dist / pinchStartDist)));

//   // đặt tx,ty để điểm neo (pinchAnchorSvg) nằm đúng dưới midpoint mới
//   const mid = ptrMidpoint(a,b);
//   const r = svg.getBoundingClientRect();
//   const midLocalX = mid.x - r.left;
//   const midLocalY = mid.y - r.top;

//   scale = ns;
//   tx = midLocalX - pinchAnchorSvg.x * scale;
//   ty = midLocalY - pinchAnchorSvg.y * scale;

//   apply();
// }

// svg.addEventListener('pointerdown', (e)=>{
//   // đừng chặn drag khi bấm vào tàu/bến 1 ngón; pinch chỉ khi có 2 ngón
//   activePtrs.set(e.pointerId, {pointerId:e.pointerId, clientX:e.clientX, clientY:e.clientY});
//   svg.setPointerCapture(e.pointerId);
//   if(activePtrs.size === 2 && !isPinching){
//     // khi bắt đầu có 2 ngón → chuyển sang pinch, vô hiệu hoá drag tạm thời
//     dragging = false;
//     startPinch();
//   }
// }, {passive:true});

// svg.addEventListener('pointermove', (e)=>{
//   if(activePtrs.has(e.pointerId)){
//     activePtrs.set(e.pointerId, {pointerId:e.pointerId, clientX:e.clientX, clientY:e.clientY});
//     if(isPinching){
//       updatePinch();
//       return;  
//     }
//   }
 
// }, {passive:true});

// function endPointer(e){
//   activePtrs.delete(e.pointerId);
//   svg.releasePointerCapture(e.pointerId);
//   if(activePtrs.size < 2){
//     isPinching = false;
//   }
// }
// svg.addEventListener('pointerup', endPointer, {passive:true});
// svg.addEventListener('pointercancel', endPointer, {passive:true});
// svg.addEventListener('pointerout', endPointer, {passive:true});
// svg.addEventListener('pointerleave', endPointer, {passive:true});

new ResizeObserver(()=>{
  if (!userInteracted) {
 
    fitHeight();
  } else {
    
    apply();
  }
}).observe(stage);
 
const seaClipRect=document.getElementById('seaClipRect');
(function(){const left=SEA.x1+SEA_PAD,right=SEA.x2-SEA_PAD;seaClipRect.setAttribute('x',left);seaClipRect.setAttribute('y',SEA.y-SEA.height);seaClipRect.setAttribute('width',right-left);seaClipRect.setAttribute('height',SEA.height);})();

 
// function loadData(){
//   const raw=localStorage.getItem('portMapData'); const warn=document.getElementById('warn');
//   if(!raw){warn.style.display='block';throw new Error('Không có localStorage["portMapData"].');}
//   try{return JSON.parse(raw);}catch(e){warn.textContent='JSON lỗi trong localStorage.';warn.style.display='block';throw e;}
// }

 async function loadData(){
  const warn = document.getElementById('warn');

 
  const raw = localStorage.getItem('portMapData');
  if (raw) {
    try {
      return JSON.parse(raw);
    } catch (e) {
      console.error('JSON lỗi trong localStorage:', e);
      warn.style.display = 'block';
      warn.textContent = 'JSON lỗi trong localStorage. Sẽ thử file dữ liệu mặc định...';
      
    }
  }

 
  try {
    const res = await fetch('port-map.data.json', { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const obj = await res.json();

 
    if (obj && typeof obj.data === 'string') {
      return JSON.parse(obj.data);
    }

    // Nếu đã là object chuẩn
    if (obj && (obj.BerthData || obj.ShipData || obj.JobData)) {
      return obj;
    }

    throw new Error('File port-map.data.json không đúng cấu trúc.');
  } catch (e) {
    console.error('Không load được file fallback:', e);
    warn.style.display = 'block';
    warn.textContent = 'Không có dữ liệu (localStorage và file JSON đều lỗi).';
    throw e;
  }
}

function normalizeUnits(berths){return Math.max(...berths.map(b=>+b.PosTo||0));}
function buildUnitToPx(totalUnits){const origin=SEA.x1+SEA_PAD,right=SEA.x2-SEA_PAD,usableW=right-origin,pxPerUnit=usableW/totalUnits;return{origin,rightBound:right,usableW,pxPerUnit,uToPx:u=>origin+u*pxPerUnit};}
function getShipSpanUAbsolute(ship,totalUnits){let u1=+ship.PosFrom||0,u2=+ship.PosTo||0;if(!(u1>0&&u2>0)){const f=+ship.FROM_POS||0,t=+ship.TO_POS||0;if(f>0&&t>0){let k=1,mx=Math.max(f,t);if(mx>totalUnits*8&&mx<totalUnits*200)k=10;if(mx>=totalUnits*200)k=100;u1=f/k;u2=t/k;}}if(u2<u1)[u1,u2]=[u2,u1];u1=Math.max(0,Math.min(u1,totalUnits));u2=Math.max(0,Math.min(u2,totalUnits));return (u2-u1>1)?{u1,u2}:null;}
function findBerthForSpan(span,berths){let best=null,bestLen=0;for(const b of berths){const a=+b.PosFrom||0,z=+b.PosTo||0;const l=Math.max(0,Math.min(span.u2,z)-Math.max(span.u1,a));if(l>bestLen){bestLen=l;best=b;}}return best;}
function intersectSpanWithBerth(span,berth){const b1=+berth.PosFrom||0,b2=+berth.PosTo||0;const u1=Math.max(span.u1,b1),u2=Math.min(span.u2,b2);return (u2-u1>1)?{u1,u2}:null;}
function progressFromJobs(jobData,shipKey){const jobs=(jobData||[]).filter(j=>j.ShipKey===shipKey);const total=jobs.reduce((s,j)=>s+(+j.JobCount||0),0);const done=jobs.reduce((s,j)=>s+((j.Status==='F'||j.Status==='R')?(+j.JobCount||0):0),0);return total?Math.round(100*done/total):0;}
function assignLanes(spansPx,minGapPx=6){const lanesEnd=[];spansPx.forEach(s=>{let lane=0;while(lane<lanesEnd.length&&s.x1<=lanesEnd[lane]+minGapPx)lane++;if(lane===lanesEnd.length)lanesEnd.push(s.x2);else lanesEnd[lane]=s.x2;s.lane=lane;});return lanesEnd.length;}
function svgEl(tag,attrs={},text){const el=document.createElementNS('http://www.w3.org/2000/svg',tag);for(const k in attrs)el.setAttribute(k,attrs[k]);if(text!=null)el.textContent=text;return el;}

const shipPanel=document.getElementById('shipPanel');
const el=(id)=>document.getElementById(id);
document.getElementById('closePanel').onclick=()=>shipPanel.style.display='none';
function showPanel(m){el('pName').textContent=m.shipName;el('pShipName').textContent=m.shipName;el('pShipKey').textContent=m.shipKey;el('pBerth').textContent=m.berthName;el('pSpan').textContent=m.uSpan;el('pSize').textContent=m.size;el('pProg').textContent=`${m.progress}%`;el('pEtaEtd').textContent=`${m.eta} → ${m.etd}`;shipPanel.style.display='block';}

const berthPanel=document.getElementById('berthPanel');
document.getElementById('closeBerth').onclick=()=>{berthPanel.style.display='none';document.querySelectorAll('.berth.active').forEach(n=>n.classList.remove('active'));};

const berthsLayer=document.getElementById('layer-berths');
function drawBerths(berths,uMap){
  berthsLayer.innerHTML='';
  const seaBottomY=SEA.y;

  const lineTop    = seaBottomY + 10;
  const lineBottom = lineTop + 20;

 
(function drawZeroMark(){
  const x0 = uMap.uToPx(0);

   
  berthsLayer.appendChild(svgEl('line',{
    x1:x0, y1:lineTop, x2:x0, y2:lineBottom,
    stroke:'#ff8a00','stroke-width':2,'pointer-events':'none'
  }));

 
  berthsLayer.appendChild(svgEl('line',{
    x1:x0, y1:lineBottom, x2:x0 + 35, y2:lineBottom,
    stroke:'#ff8a00','stroke-width':2,'pointer-events':'none'
  }));
 

  const g0 = svgEl('g',{ transform:`translate(${x0},${lineTop-10})`, 'pointer-events':'none' });
  berthsLayer.appendChild(g0);
  const t0 = svgEl('text',{ x:0,y:4,'text-anchor':'middle','font-size':11,'font-weight':700, fill:'#fff' }, '0.0m');
  g0.appendChild(t0);
  requestAnimationFrame(()=>{
    const bb=t0.getBBox(), padX=6, padY=3;
    const r=svgEl('rect',{ x:bb.x-padX, y:bb.y-padY, width:bb.width+padX*2, height:bb.height+padY*2, rx:4, ry:4, fill:'#ff8a00', stroke:'#fff','stroke-width':1 });
    g0.insertBefore(r,t0);
  });
})();

 
  (berths||[]).forEach((b, i, arr)=>{
    const u1=+b.PosFrom||0,u2=+b.PosTo||0;if(u2<=u1)return;
    
  const endX = uMap.uToPx(u2);
    berthsLayer.appendChild(svgEl('line',{
      x1:endX, y1:lineTop, x2:endX, y2:lineBottom,
      stroke:'#ff8a00','stroke-width':2,'pointer-events':'none'
    }));
  if (i === arr.length - 1) {
    const xLeft = Math.max(endX - 30, uMap.origin);  
    berthsLayer.appendChild(svgEl('line', {
      x1: endX, y1: lineBottom, x2: xLeft, y2: lineBottom,
      stroke: '#ff8a00', 'stroke-width': 2, 'pointer-events': 'none'
    }));
  }
 
    const gLabel = svgEl('g',{ transform:`translate(${endX},${lineTop-10})`, 'pointer-events':'none' });
    berthsLayer.appendChild(gLabel);

    const labelText = `${u2.toFixed(1)}m`;
    const textEl = svgEl('text',{
      x:0, y:4, 'text-anchor':'middle',
      'font-size':11,'font-weight':700, fill:'#fff'
    }, labelText);
    gLabel.appendChild(textEl);

    requestAnimationFrame(()=>{
      const bb = textEl.getBBox(), padX=6, padY=3;
      const rect = svgEl('rect',{
        x:bb.x - padX, y:bb.y - padY,
        width:bb.width + padX*2,
        height:bb.height + padY*2,
        rx:4, ry:4,
        fill:'#ff8a00', stroke:'#fff','stroke-width':1
      });
      gLabel.insertBefore(rect, textEl);
    });


    const cx=(uMap.uToPx(u1)+uMap.uToPx(u2))/2;
    const spanPx=Math.max(24,(uMap.uToPx(u2)-uMap.uToPx(u1)));
    const tabW=Math.max(56,Math.min(180,spanPx*0.45))/2,tabH=18;

    const g=svgEl('g',{class:'berth',transform:`translate(${cx},${seaBottomY+2})`,style:'cursor:pointer'});
    berthsLayer.appendChild(g);
  g.appendChild(svgEl('rect',{x:-tabW/2,y:-tabH+16,width:tabW,height:tabH,rx:6,fill:'#ff8a00'}));
    g.appendChild(svgEl('text',{x:0,y:12,'font-size':12,'font-weight':700,fill:'#fff','text-anchor':'middle'},
      (b.BerthName||b.BerthNo||'Bến')));
    const hit=svgEl('rect',{x:-tabW/2-12,y:-tabH-12,width:tabW+24,height:tabH+26,fill:'#000','fill-opacity':'0.001'});g.appendChild(hit);

    function fillBerthPanel(){
      el('bTitle').textContent=b.BerthName||b.BerthNo||'Bến';
      el('bNo').textContent=b.BerthNo||'—';
      el('bLen').textContent=(b.BerthLength!=null?b.BerthLength:(u2-u1)).toString();
      el('bDepth').textContent=(b.BerthDepth!=null?b.BerthDepth:'—').toString();
      el('bPayload').textContent=(b.Payload!=null?b.Payload:'—').toString();
      el('bSpan').textContent=`${u1} → ${u2}`;
    }

   
    g.addEventListener('click',()=>{
      document.querySelectorAll('.berth.active').forEach(n=>n.classList.remove('active'));
      g.classList.add('active');
      // fillBerthPanel();
      // berthPanel.style.display='block';
     
  showPopoverBerth(b, u1, u2, g);
    });

 
    if (CAN_HOVER){
      let hideT=null;
      g.addEventListener('mouseenter',()=>{
        clearTimeout(hideT);
        g.querySelector('rect').setAttribute('fill','#163a6b');
        if (!g.classList.contains('active')) {  showPopoverBerth(b, u1, u2, g); }
      });
      g.addEventListener('mouseleave',()=>{
           g.querySelector('rect').setAttribute('fill','#ff8a00');
        if (g.classList.contains('active')) return;  
      hideT = setTimeout(hidePopover, 160);
      });
        pop.addEventListener('mouseenter',()=>clearTimeout(hideT));
  pop.addEventListener('mouseleave',()=>{ hideT=setTimeout(hidePopover,160); });
      // berthPanel.addEventListener('mouseenter',()=>clearTimeout(hideT));
      // berthPanel.addEventListener('mouseleave',()=>{ 
    
      //   const anyActive=document.querySelector('.berth.active');
      //   if (!anyActive) berthPanel.style.display='none';
      // });
    }
  });
}
function showPopoverBerth(b, u1, u2, anchorG){
  const len = (b.BerthLength != null ? b.BerthLength : (u2 - u1));
  popTitle.textContent = b.BerthName || b.BerthNo || 'Bến';
  popBody.innerHTML = `
    <table>
      <tr><td>Mã bến</td><td>${b.BerthNo || '—'}</td></tr>
      <tr><td>Tên bến</td><td>${b.BerthName || '—'}</td></tr>
      <tr><td>Chiều dài (m)</td><td>${len}</td></tr>
      <tr><td>Độ sâu TK</td><td>${(b.BerthDepth != null ? b.BerthDepth : '—')}</td></tr>
      <tr><td>Tải trọng (tấn)</td><td>${(b.Payload != null ? b.Payload : '—')}</td></tr>
      <tr><td>Vị trí (u)</td><td>${u1} → ${u2}</td></tr>
    </table>`;
  showPopoverForSvgAnchor(anchorG, 'above');
}
 const pop = document.getElementById('pop');
const popTitle = document.getElementById('popTitle');
const popBody = document.getElementById('popBody');

function hidePopover(){ pop.classList.remove('show','above','below'); }
document.addEventListener('pointerdown', e => { if (!pop.contains(e.target)) hidePopover(); });
document.addEventListener('keydown', e => { if (e.key === 'Escape') hidePopover(); });

function showPopoverAtClient(cx, cy, prefer='above'){
  pop.style.left='0px'; pop.style.top='0px';
  pop.classList.add('show');

  const r0 = pop.getBoundingClientRect();
  const flip = (prefer==='above' && (cy - r0.height - 16 < 8));
  const mode = flip ? 'below' : prefer;
  pop.classList.remove('above','below'); pop.classList.add(mode);

  const r = pop.getBoundingClientRect();
  const vw = window.innerWidth, vh = window.innerHeight;
  let left = Math.round(cx - r.width/2);
  let top  = Math.round(mode==='above' ? (cy - r.height - 14) : (cy + 14));
  left = Math.max(8, Math.min(left, vw - r.width - 8));
  top  = Math.max(8, Math.min(top,  vh - r.height - 8));
  pop.style.left = left+'px';
  pop.style.top  = top +'px';

  const ax = Math.max(16, Math.min(cx - left, r.width - 16));  
  pop.style.setProperty('--ax', ax + 'px');
}

function showPopoverForSvgAnchor(svgNode, prefer='above'){
  const rect = svgNode.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = prefer === 'above' ? rect.top : rect.bottom;
  showPopoverAtClient(cx, cy, prefer);
}
const shipsLayer=document.getElementById('layer-ships');
function drawShips(ships,berths,uMap,jobData){
  shipsLayer.innerHTML='';
  const seaBottomY=SEA.y, laneMaxH=Math.max(10,SEA.height-8);
  const seen=new Set(); const uniq=ships.filter(s=>{if(seen.has(s.ShipKey))return false; seen.add(s.ShipKey); return true;});
  const totalU=uMap.usableW/uMap.pxPerUnit; const grouped=new Map();

  uniq.forEach(s=>{
    const spanAbs=getShipSpanUAbsolute(s,totalU); if(!spanAbs)return;
    const berthReal=findBerthForSpan(spanAbs,berths); if(!berthReal)return;
    const spanInBerth=intersectSpanWithBerth(spanAbs,berthReal); if(!spanInBerth)return;
    let x1=uMap.uToPx(spanInBerth.u1)+PAD_VIS, x2=uMap.uToPx(spanInBerth.u2)-PAD_VIS; if(x2<=x1)x2=x1+30;
    const arr=grouped.get(berthReal.BerthNo)||[]; arr.push({ship:s,berth:berthReal,u:spanInBerth,px:{x1,x2}}); grouped.set(berthReal.BerthNo,arr);
  });

  for (const [,items] of grouped.entries()){
    items.sort((a,b)=>a.px.x1-b.px.x1);
    const spans=items.map(it=>({x1:it.px.x1,x2:it.px.x2}));
    const lanesCount=assignLanes(spans,6);
    const laneHeight=Math.max(MIN_SHIP_HEIGHT,Math.floor((laneMaxH-(lanesCount-1)*LANE_GAP_PX)/lanesCount));

    items.forEach((it,idx)=>{
      const lane=spans[idx].lane, w=Math.max(12,it.px.x2-it.px.x1), ppm=uMap.pxPerUnit;
      const loaM=w/ppm, estBeamM=(it.ship.BeamM&&+it.ship.BeamM>0)?+it.ship.BeamM:loaM*0.12;
      let h=Math.min(laneHeight,Math.max(MIN_SHIP_HEIGHT,estBeamM*ppm*BEAM_VISUAL_SCALE));
      const cx=(it.px.x1+it.px.x2)/2, baseY=seaBottomY-1-lane*(h+LANE_GAP_PX);

      const g=svgEl('g',{class:'ship',transform:`translate(${cx},${baseY})`,'data-shipkey':it.ship.ShipKey});
      shipsLayer.appendChild(g);
      const spr=Math.random()<0.5?SHIP_SPRITES[0]:SHIP_SPRITES[1];
      g.appendChild(svgEl('image',{href:spr.src,x:-w/2,y:-h,width:w,height:h,preserveAspectRatio:'xMidYMid meet'}));

      const prog=progressFromJobs(jobData,it.ship.ShipKey);
      const trackW=10, trackH=Math.max(20,Math.floor(h*0.9)), trackY=-h+Math.floor((h-trackH)/2);
      const seaL=SEA.x1+SEA_PAD, seaR=SEA.x2-SEA_PAD, TEXT_W=36,GAP_OUT=6,GAP_TX=6,UI_W=trackW+GAP_TX+TEXT_W;
      let trackX=w/2-GAP_OUT+40, textX=trackX+trackW+GAP_TX;
  
      trackX=w/2-(trackW+40); textX=trackX+trackW+GAP_TX;
 
      // if (cx+(w/2)+GAP_OUT+UI_W>seaR){ trackX=-w/2-GAP_OUT-trackW; textX=trackX+trackW+GAP_TX; if (cx+trackX<seaL){ trackX=w/2-(trackW+4); textX=trackX+trackW+GAP_TX; } }
      const fillH=Math.round(trackH*(prog/100)), fillY=trackY+(trackH-fillH);
      g.appendChild(svgEl('rect',{x:trackX,y:trackY,width:trackW,height:trackH,rx:trackW/2,fill:'#e9ecef'}));
      g.appendChild(svgEl('rect',{x:trackX,y:fillY,width:trackW,height:fillH,rx:trackW/2,fill:'#34c759'}));
      g.appendChild(svgEl('text',{x:textX+8,y:trackY/2,'font-size':16,'font-weight':700,fill:'#1d3f77'},`${prog}%`));

      const hit=svgEl('rect',{class:'hit',x:-w/2-12,y:-h-12,width:w+24,height:h+24,fill:'#000','fill-opacity':'0.001'}); g.appendChild(hit);

      const meta = {
  shipName: it.ship.ShipName,
  shipKey: it.ship.ShipKey,
  berthName: (it.berth.BerthName||it.berth.BerthNo),
  uSpan: `${it.u.u1.toFixed(1)} → ${it.u.u2.toFixed(1)} (pxPerUnit=${ppm.toFixed(3)})`,
  size: `~${loaM.toFixed(1)} m × ${(estBeamM).toFixed(1)} m`,
  progress: prog,
  eta: it.ship.ETA || '—',
  etd: it.ship.ETD || it.ship.Etd || '—',
  equipment: it.ship.Equipment || '',
  oprId: it.ship.OprId || it.ship.oprId || '—'   ,
  uRange: `${it.u.u1.toFixed(1)} → ${it.u.u2.toFixed(1)}`,
pxPerUnit: ppm.toFixed(3) 
};
hit.addEventListener('pointerup', (e)=>{
  e.stopPropagation();
   showPopoverShip(meta, g);
}, {passive:true});
      
      if (CAN_HOVER){
        let hideT=null;
        g.addEventListener('mouseenter',()=>{clearTimeout(hideT); showPopoverShip(meta, g);});
       g.addEventListener('mouseleave',()=>{
    hideT=setTimeout(hidePopover,160);
  });
  pop.addEventListener('mouseenter',()=>clearTimeout(hideT));
  pop.addEventListener('mouseleave',()=>{ hideT=setTimeout(hidePopover,160); });
      }
    });
  }
}

function fmtDate(s){
  if(!s) return '—';
  const d = new Date(s);
  if(isNaN(d)) return s;
  const pad=n=>n.toString().padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
}

function showPopoverShip(meta, anchorG){
 
  const equipStr = (meta.equipment || meta.Equipment || '').trim();
  const eqList = equipStr ? equipStr.split(';').filter(x=>x && x!=='*') : [];
  const gangs = eqList.length || '—';

  popTitle.textContent = meta.shipName || 'Tàu';

  popBody.innerHTML = `
    <div class="sec blue table">
      <div class="sec-hd">${meta.shipName || '—'}</div>
      <div class="sec-body">
        <table>
          <tr>
            <td>Hãng tàu</td>
           <td>${meta.oprId || meta.OprId || '—'}</td>
          </tr>
          <tr>
            <td>Bến</td>
            <td>${meta.berthName || '—'}</td>
          </tr>
          <tr>
            <td>Số cẩu</td>
            <td><span class="pill blue">${gangs}</span></td>
          </tr>
          <tr>
            <td>Tiến độ</td>
            <td><span class="pill green">${(meta.progress ?? '—')}%</span></td>
          </tr>
        </table>
      </div>
    </div>

    <div class="sec amber table">
      <div class="sec-hd">Thời gian</div>
      <div class="sec-body">
        <table>
          <tr><td>ETA</td><td>${fmtDate(meta.eta)}</td></tr>
          <tr><td>ETD</td><td>${fmtDate(meta.etd)}</td></tr>
        </table>
      </div>
    </div>

    <div class="sec gray table">
      <div class="sec-hd">Khung tàu</div>
      <div class="sec-body">
        <table>
          <tr><td>Mã chuyến</td><td>${meta.shipKey || '—'}</td></tr>
     <tr>
  <td>Vị trí (u)</td>
  <td>${meta.uRange || '—'}</td>
</tr>
<tr>
  <td>px/Unit</td>
  <td>${meta.pxPerUnit || '—'}</td>
</tr>
          <tr class="sum-row"><td>Kích thước ước tính</td><td>${meta.size || '—'}</td></tr>
        </table>
      </div>
    </div>
  `;

  showPopoverForSvgAnchor(anchorG, 'above');
}
const jobsCard=document.getElementById('jobsCard');
const toggleBtn=document.getElementById('toggleJobs');
const jobsBody=document.getElementById('jobsBody');
const jobsToggle=document.getElementById('jobsToggle');

 
toggleBtn.onclick=()=>{
  const open=!jobsCard.classList.contains('open');
  jobsCard.classList.toggle('open',open);
  toggleBtn.classList.toggle('rotate',open);
  if(open){ jobsBody.style.display='block'; jobsToggle.textContent='Ẩn ▲'; }
};

 
jobsToggle.onclick=()=>{
  const open=jobsBody.style.display!=='none';
  jobsBody.style.display=open?'none':'block';
  jobsToggle.textContent=open?'Hiện ▼':'Ẩn ▲';
};

function buildJobsUI(ships, berths, jobData){
  const tbody=document.querySelector('#jobsTable tbody'); tbody.innerHTML='';
  const cards=document.getElementById('jobsCards'); cards.innerHTML='';
  const seen=new Set();
  const rows=ships.filter(s=>{if(seen.has(s.ShipKey))return false; seen.add(s.ShipKey); return true;})
    .map(s=>{
      const totalU=Math.max(...(berths||[]).map(b=>+b.PosTo||0));
      const span=getShipSpanUAbsolute(s,totalU);
      const berthReal=span?findBerthForSpan(span,berths||[]):null;
      const berthName=berthReal?(berthReal.BerthName||berthReal.BerthNo):(s.BerthNo||'—');
      const prog=progressFromJobs(jobData,s.ShipKey);
      return {key:s.ShipKey,ship:s.ShipName||'—',berth:berthName,eta:s.ETA||'—',etd:s.ETD||s.Etd||'—',prog};
    })
    .sort((a,b)=>(a.berth||'').localeCompare(b.berth||'')||(b.prog-a.prog));

  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${r.berth}</td><td class="ship">${r.ship}</td>
      <td class="hide-sm">${r.key}</td><td class="hide-sm">${r.eta} → ${r.etd}</td>
      <td style="min-width:160px"><div class="bar"><i style="width:${r.prog}%;color: black;">${r.prog}%</i></div></td>`;
    tr.addEventListener('click',()=>focusShipByKey(r.key));
    tbody.appendChild(tr);
  });

  rows.forEach(r=>{
    const div=document.createElement('div');
    div.className='card';
    div.innerHTML=`
      <div class="hdr">${r.ship}</div>
      <div class="cols">
        <div>Bến</div><div>${r.berth}</div>
        <div>ShipKey</div><div>${r.key}</div>
        <div>ETA</div><div>${r.eta}</div>
        <div>ETD</div><div>${r.etd}</div>
        <div>Tiến độ</div><div><div class="bar"><i style="width:${r.prog}%;color: black;">${r.prog}%</i></div></div>
      </div>`;
    div.addEventListener('click',()=>{ focusShipByKey(r.key); jobsCard.classList.remove('open'); toggleBtn.classList.remove('rotate'); });
    cards.appendChild(div);
  });
}

 
function focusShipByKey(shipKey){
  const g=shipsLayer.querySelector(`g.ship[data-shipkey="${shipKey}"]`);
  if(!g)return;
  const tr=g.getCTM(), worldX=tr.e, vw=stage.clientWidth;
  const targetTx=(vw/2)-worldX*scale; const startTx=tx; const dur=250; const t0=performance.now();
  function anim(t){const k=Math.min(1,(t-t0)/dur); tx=startTx+(targetTx-startTx)*k; apply(); if(k<1) requestAnimationFrame(anim);}
  requestAnimationFrame(anim);
}
function setViewByHeight(mult = 1.2, center = 'map'){
  const vw = stage.clientWidth, vh = stage.clientHeight;

 
  const base = vh / MAP.H;
  const ns = Math.max(MIN, Math.min(MAX, base * mult));
  scale = ns*2.6;


  let cx, cy;
  if(center === 'sea'){
    cx = (SEA.x1 + SEA.x2) / 2;
    cy = SEA.y - SEA.height / 2;
  } else {
    cx = MAP.W / 2;
    cy = MAP.H / 2;
  }

 const currentWidth  = MAP.W * scale;
 const currentHeight = MAP.H * scale;

  // tx = (vw/2) - cx * scale+1000;
  // ty = (vh/2) - cy * scale+500;
 
  // apply();
 
  userInteracted = true;
}

function zoomHeightNow(mult = 1.0, center = 'map'){ 
  const vw = stage.clientWidth, vh = stage.clientHeight*2;
  const base = vh / MAP.H;                       
  const ns = Math.max(MIN, Math.min(MAX, base * mult));
  if(vw<1000)
  scale = ns+0.8;
else if(vw>1700) scale=ns-0.13;
  else scale=ns+0.35;
  if(center === 'sea'){                      
    const cx = (SEA.x1 + SEA.x2) / 2;
    const cy = SEA.y - SEA.height / 2;
    tx = (vw/2) - cx * scale;
    ty = (vh/2) - cy * scale;
  } else {                                       
    tx = (vw - MAP.W * scale) / 2;
    ty = (vh - MAP.H * scale) / 2;
  }
 const currentWidth  = MAP.W * scale;
 const currentHeight = MAP.H * scale;
if(vw>=1000 && vw <=1700){
  tx=(vw-currentWidth)/7;
ty=(vh-currentHeight)/2+100;

}else if(vw>1700){
tx=(vw-currentWidth)/5;
ty=(vh-currentHeight)-190;
}
else{
    tx=(vw-currentWidth)/6;
ty=(vh-currentHeight)/3;
}

  apply();
 
  userInteracted = true;
}
// (function boot(){
//   const raw=loadData();
//   const berths=(raw.BerthData||[]).slice().sort((a,b)=>(+a.PosFrom||0)-(+b.PosFrom||0));
//   const ships=raw.ShipData||[], jobs=raw.JobData||[];
//   const totalUnits=normalizeUnits(berths), uMap=buildUnitToPx(totalUnits);
//   drawBerths(berths,uMap);
//   drawShips(ships,berths,uMap,jobs);
//   buildJobsUI(ships,berths,jobs);
 
//   requestAnimationFrame(() => zoomHeightNow(1.2, 'map'));
// })();
(async function boot(){
  try{
    const raw = await loadData();

    const berths = (raw.BerthData||[]).slice().sort((a,b)=>(+a.PosFrom||0)-(+b.PosFrom||0));
    const ships  = raw.ShipData || [];
    const jobs   = raw.JobData || [];

    const totalUnits = normalizeUnits(berths);
    const uMap = buildUnitToPx(totalUnits);

    drawBerths(berths, uMap);
    drawShips(ships, berths, uMap, jobs);
    buildJobsUI(ships, berths, jobs);

    // nếu bạn có auto-zoom ban đầu thì giữ lại:
    requestAnimationFrame(()=> zoomHeightNow(1.2, 'map'));

  }catch(e){
    console.error('Boot failed:', e);
  }
})();
window.addEventListener('DOMContentLoaded', () => {
 
  if (!userInteracted) requestAnimationFrame(() => zoomHeightNow(1.2, 'map'));
});
window.addEventListener('orientationchange', () => {
 
  setTimeout(() => zoomHeightNow(1.2, 'map'), 150);
});
</script>
</body>
</html>
